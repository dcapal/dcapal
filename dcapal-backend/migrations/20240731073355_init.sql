-- Custom types
create type public.role_status as enum ('active', 'inactive');
create type public.app_role as enum ('admin', 'authenticated');

-- USERS
create table public.users
(
    id         uuid references auth.users not null primary key, -- UUID from auth.users
    first_name text                       not null,
    last_name  text,
    email      text                       not null unique,
    birthdate  date
);

-- ROLES
create table public.roles
(
    id     bigint generated by default as identity primary key,
    name   app_role                     not null,
    status role_status default 'active' not null
);

-- USER ROLES
create table public.user_roles
(
    id      bigint generated by default as identity primary key,
    user_id uuid references public.users on delete cascade not null,
    role_id bigint references public.roles                 not null,
    unique (user_id, role_id)
);

-- PERMISSIONS
create table public.permissions
(
    id   bigint generated by default as identity primary key,
    name text not null unique
);

-- ROLE PERMISSIONS
create table public.role_permissions
(
    id            bigint generated by default as identity primary key,
    role_id       bigint references public.roles       not null,
    permission_id bigint references public.permissions not null,
    unique (role_id, permission_id)
);


-- Secure the tables
alter table public.users
    enable row level security;
alter table public.user_roles
    enable row level security;
alter table public.role_permissions
    enable row level security;
create policy "Allow logged-in read access" on public.users for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.users for insert with check (auth.uid() = id);
create policy "Allow individual update access" on public.users for update using (auth.uid() = id);
create policy "Allow individual read access" on public.user_roles for select using (auth.uid() = user_id);

-- Send "previous data" on change
alter table public.users
    replica identity full;

-- inserts a row into public.users and assigns roles
create function public.handle_new_user()
    returns trigger as
$$
declare
    is_admin boolean;
begin
    insert into public.users (id, email)
    values (new.id, new.email);

    return new;
end;
$$ language plpgsql security definer
                    set search_path = auth, public;

-- trigger the function every time a user is created
create trigger on_auth_user_created
    after insert
    on auth.users
    for each row
execute procedure public.handle_new_user();


-- REALTIME SUBSCRIPTIONS
-- Only allow realtime listening on public tables.
begin;
-- remove the realtime publication
drop publication if exists supabase_realtime;

-- re-create the publication but don't enable it for any tables
create publication supabase_realtime;
commit;

-- add tables to the publication
alter publication supabase_realtime add table public.users;
